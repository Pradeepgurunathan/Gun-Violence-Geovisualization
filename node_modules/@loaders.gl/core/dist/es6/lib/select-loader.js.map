{"version":3,"sources":["../../../src/lib/select-loader.js"],"names":["getRegisteredLoaders","normalizeLoader","EXT_PATTERN","selectLoader","loaders","url","data","nothrow","Array","isArray","loader","normalizeLoaders","replace","findLoaderByUrl","findLoaderByExamingInitialData","Error","match","extension","findLoaderByExtension","toLowerCase","loaderExtension","extensions","testText","ArrayBuffer","isView","testBinary","buffer","byteOffset","type","test","tests","some","magic","getMagicString","length","arrayBuffer","byteLength","dataView","DataView","i","String","fromCharCode","getUint8"],"mappings":"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","sourcesContent":["import {getRegisteredLoaders} from './register-loaders';\nimport {normalizeLoader} from './loader-utils/normalize-loader';\n\nconst EXT_PATTERN = /[^.]+$/;\n\n// Find a loader that matches file extension and/or initial file content\n// Search the loaders array argument for a loader that matches url extension or initial data\n// Returns: a normalized loader\n\n// TODO - Need a variant that peeks at streams for parseInBatches\n// TODO - Detect multiple matching loaders? Use heuristics to grade matches?\n// TODO - Allow apps to pass context to disambiguate between multiple matches (e.g. multiple .json formats)?\n\nexport function selectLoader(loaders, url = '', data = null, {nothrow = false} = {}) {\n  url = url || '';\n\n  // if only a single loader was provided (not as array), force its use\n  // TODO - Should this behaviour be kept and documented?\n  if (loaders && !Array.isArray(loaders)) {\n    const loader = loaders;\n    normalizeLoader(loader);\n    return loader;\n  }\n\n  // If no loaders provided, get the registered loaders\n  loaders = loaders || getRegisteredLoaders();\n  normalizeLoaders(loaders);\n\n  url = url.replace(/\\?.*/, '');\n  let loader = null;\n  loader = loader || findLoaderByUrl(loaders, url);\n  loader = loader || findLoaderByExamingInitialData(loaders, data);\n\n  // no loader available\n  if (!loader) {\n    if (nothrow) {\n      return null;\n    }\n    throw new Error(`No valid loader found for ${url}`);\n  }\n\n  return loader;\n}\n\nfunction normalizeLoaders(loaders) {\n  for (const loader of loaders) {\n    normalizeLoader(loader);\n  }\n}\n\n// TODO - Would be nice to support http://example.com/file.glb?parameter=1\n// E.g: x = new URL('http://example.com/file.glb?load=1'; x.pathname\nfunction findLoaderByUrl(loaders, url) {\n  // Get extension\n  const match = url.match(EXT_PATTERN);\n  const extension = match && match[0];\n  const loader = extension && findLoaderByExtension(loaders, extension);\n  return loader;\n}\n\nfunction findLoaderByExtension(loaders, extension) {\n  extension = extension.toLowerCase();\n\n  for (const loader of loaders) {\n    for (const loaderExtension of loader.extensions) {\n      if (loaderExtension.toLowerCase() === extension) {\n        return loader;\n      }\n    }\n  }\n  return null;\n}\n\nfunction findLoaderByExamingInitialData(loaders, data) {\n  if (!data) {\n    return null;\n  }\n\n  for (const loader of loaders) {\n    if (typeof data === 'string') {\n      if (testText(data, loader)) {\n        return loader;\n      }\n    } else if (ArrayBuffer.isView(data)) {\n      // Typed Arrays can have offsets into underlying buffer\n      if (testBinary(data.buffer, data.byteOffset, loader)) {\n        return loader;\n      }\n    } else if (data instanceof ArrayBuffer) {\n      const byteOffset = 0;\n      if (testBinary(data, byteOffset, loader)) {\n        return loader;\n      }\n    }\n    // TODO Handle streaming case (requires creating a new AsyncIterator)\n  }\n  return null;\n}\n\nfunction testText(data, loader) {\n  return loader.testText && loader.testText(data);\n}\n\nfunction testBinary(data, byteOffset, loader) {\n  const type = Array.isArray(loader.test) ? 'array' : typeof loader.test;\n  switch (type) {\n    case 'function':\n      return loader.test(data, loader);\n\n    case 'string':\n    case 'array':\n      // Magic bytes check: If `loader.test` is a string or array of strings,\n      // check if binary data starts with one of those strings\n      const tests = Array.isArray(loader.test) ? loader.test : [loader.test];\n      return tests.some(test => {\n        const magic = getMagicString(data, byteOffset, test.length);\n        return test === magic;\n      });\n\n    default:\n      return false;\n  }\n}\n\nfunction getMagicString(arrayBuffer, byteOffset, length) {\n  if (arrayBuffer.byteLength <= byteOffset + length) {\n    return '';\n  }\n  const dataView = new DataView(arrayBuffer);\n  let magic = '';\n  for (let i = 0; i < length; i++) {\n    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));\n  }\n  return magic;\n}\n"],"file":"select-loader.js"}